## 流程

### 客户端进行方法的调用，将自己的方法调用转换为request
### 以下为转换方法
```java

 @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //构建request,将客户端的请求方法转换为request
        RpcRequest request=RpcRequest.builder()
                .interfaceName(method.getDeclaringClass().getName())
                .methodName(method.getName())
                .params(args).paramsType(method.getParameterTypes()).build();
        //IOClient.sendRequest 和服务端进行数据传输
        RpcResponse response= IOClient.sendRequest(host,port,request);
        return response.getData();//进行获取运算后的数据

```

### 以下为RPCrequest的结构体

```java

@Data
@Builder
public class RpcRequest implements Serializable {
    //服务类名，客户端只知道接口
    private String interfaceName;
    //调用的方法名
    private String methodName;
    //参数列表
    private Object[] params;
    //参数类型
    private Class<?>[] paramsType;
}

```

### request传递到IOClient进行底层数据通讯（to host）-在part2中client中增加了netty

``` java

public class IOClient {
    //这里负责底层与服务端的通信，发送request，返回response
    public static RpcResponse sendRequest(String host, int port, RpcRequest request){
        try {
            Socket socket=new Socket(host, port);
            ObjectOutputStream oos=new ObjectOutputStream(socket.getOutputStream());
            ObjectInputStream ois=new ObjectInputStream(socket.getInputStream());

            oos.writeObject(request);//将流进行写入流中
            oos.flush();//强制刷新到基础流中

            RpcResponse response=(RpcResponse) ois.readObject();//获取回应体
            return response;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}

```

### 管理链接（单线程版本/线程池版本）


### part2

### 服务端代码

## 先进行服务的注册,将接口以及接口对应的实现类进行遍历，存储到hashmap中（多个服务端共享一个hashmap的时候需要考虑线程安全）

```java
private Map<String,Object> interfaceProvider;

    public ServiceProvider(){
        this.interfaceProvider=new HashMap<>();
    }

    public void provideServiceInterface(Object service){
        String serviceName=service.getClass().getName();
        //获取接口名称
        Class<?>[] interfaceName=service.getClass().getInterfaces();
        //一个接口可能有多个实现类，所以需要遍历

        for (Class<?> clazz:interfaceName){
            interfaceProvider.put(clazz.getName(),service);
        }

    }

    public Object getService(String interfaceName){
        return interfaceProvider.get(interfaceName);
    }

```
